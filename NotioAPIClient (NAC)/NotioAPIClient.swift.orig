//
// ResultCallback.swift
//
// Original source meterial : https://medium.com/makingtuenti/writing-a-scalable-api-client-in-swift-4-b3c6f7f3f3fb
// by : Víctor Pimentel @ https://medium.com/@VictorPimentel
//
// Created by Pascale Beaulac on 2019-11-25.
// Copyright © 2019 Notio. All rights reserved.
//

import Foundation

public typealias ResultCallback<Value> = (Result<Value, Error>) -> Void
public enum HTTPMethods: String
{
    case post = "POST"
    case get = "GET"
    case delete = "DELETE"
}

/// Implementation of a generic-based Notio Cloud API client
public class NotioAPIClient {
    
<<<<<<< HEAD
    #if STAGING
    private static let kHOST = "https://clouduat.notio.ai"
    #else
    private static let kHOST = "https://cloud.notio.ai"
    #endif
    
    private static let kURL = kHOST + "/activity/v1/"
    
    private let baseHostUrl = URL(string: kHOST)
    private let baseEndpointUrl = URL(string: kURL)!
=======
    private static var baseHostUrl: String?

    private let baseHostUrl : URL!
    private let baseEndpointUrl : URL!
>>>>>>> dev
    private let session = URLSession(configuration: .default)
    
    private let token: String
    private let host: String
    private let url: String
    
    /// Initialize the NotioAPIClient using the default Url
    public init(token: String) {
        self.token = token

        if let baseUrl = NotioAPIClient.baseHostUrl {
            self.host = baseUrl
        } else {
            self.host = UrlConstants.baseUrl
        }

        self.url = self.host + "/activity/v1/"
        
        self.baseHostUrl = URL(string: self.host)!
        self.baseEndpointUrl = URL(string: self.url)!
    }
    
    /// Initialize the NotioAPIClient using the Url provided
    public init(token: String, baseUrl: String) {
        self.token = token

        self.host = baseUrl
        self.url = self.host + "/activity/v1/"
        
        self.baseHostUrl = URL(string: self.host)!
        self.baseEndpointUrl = URL(string: self.url)!
    }
   
    public class func setEnvironmentUrl(hostUrl: String) {
        NotioAPIClient.baseHostUrl = hostUrl
    }

    public func upLoadRideData(_ data: Data, atLocation location: String, completion: @escaping ResultCallback<Bool>)
    {
        guard let url = URL(string: location, relativeTo: baseHostUrl) else {
            completion(.failure(NACError.BadDataURL))
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.addValue(self.token, forHTTPHeaderField: "Authorization")
        request.httpBody = data
        request.httpShouldHandleCookies = false
        
        let session = URLSession(configuration: URLSessionConfiguration.default)
        let task = session.dataTask(with: request) { (data, response, error) in
            print("\(String(describing: response))")
            
            if let err = error {
                DispatchQueue.main.async {
                    completion(.failure(err))
                }
                return
            }
            
            let statusCode:Int = (response as? HTTPURLResponse)?.statusCode ?? 0
            if statusCode != 200 {
                DispatchQueue.main.async {
                    completion(.failure(NACError.BadStatusCode(statusCode)))
                }
                return
            }
            DispatchQueue.main.async {
                completion(.success(true))
            }
        }
        
        task.resume()
    }
    
    public func downloadRideData(_ cloudID: String, completition: @escaping ResultCallback<Data>) {
                
        guard let url = URL(string: "activities/data/" + cloudID, relativeTo: baseEndpointUrl ) else {
            completition(.failure(NACError.BadDataURL))
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.addValue(self.token, forHTTPHeaderField: "Authorization")
        request.setValue("application/octet-stream", forHTTPHeaderField: "Accept")
        request.httpShouldHandleCookies = false
        
        let session = URLSession(configuration: URLSessionConfiguration.default)
        let task = session.dataTask(with: request) { (data, response, error) in
            print("\(String(describing: response))")
            
            if let err = error {
                completition(.failure(err))
                return
            }
            
            let statusCode:Int = (response as? HTTPURLResponse)?.statusCode ?? 0
            if statusCode != 200 {
                completition(.failure(NACError.BadStatusCode(statusCode)))
                return
            }
            
            if let data = data {
                DispatchQueue.main.async {
                    completition(.success(data))
                }
            } else {
                DispatchQueue.main.async {
                    completition(.failure(NACError.BadResponse))
                }
            }
        }
        task.resume()
    }
    
    /// Sends a request to Notio servers, calling the completion method when finished
    public func send<T: NACRequestProtocol>(_ request: T, completion: @escaping ResultCallback<T.Response>)
    {
        let endpoint = self.endpoint(for: request)
        
        var urlRequest = URLRequest(url: endpoint)
        urlRequest.addValue(self.token, forHTTPHeaderField: "Authorization")
        urlRequest.httpMethod = request.httpMethod.rawValue
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
        urlRequest.setValue("application/json", forHTTPHeaderField: "Accept")
        
        switch request.httpMethod {
        case .get:
            break
        case .post:
            urlRequest.httpShouldHandleCookies = false
            urlRequest.httpBody = try? JSONEncoder().encode(request)
        case .delete:
            break
        }
        
        print("sending request: \(urlRequest)")
        
        let task = session.dataTask(with: urlRequest) { data, response, error in
            print("recieving response")
            
            if let error = error
            {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
                
            }
            else if let data = data
            {
                do
                {
                    print(String(data: data, encoding: .utf8) ?? "Bad JSON")
                    let cloudResponse = try JSONDecoder().decode(T.Response.self, from: data)
                    DispatchQueue.main.async {
                        completion(.success(cloudResponse))
                    }
                }
                catch let error as DecodingError{
                    print(error)
                    DispatchQueue.main.async {
                        completion(.failure(NACError.decoding))
                    }
                }
                catch
                {
                    DispatchQueue.main.async {
                        completion(.failure(NACError.BadJSON))
                    }
                }
            }
            else {
                let statusCode:Int = (response as? HTTPURLResponse)?.statusCode ?? 0
                if statusCode != 200 {
                    DispatchQueue.main.async {
                        completion(.failure(NACError.BadStatusCode(statusCode)))
                    }
                }
            }
        }
        task.resume()
    }
    
    /// Encodes a URL based on the given request
    /// Everything needed to form a reques where additional path components are needed as setup here.
    private func endpoint<T: NACRequestProtocol>(for request: T) -> URL {
        guard var baseUrl = URL(string: request.resourceName, relativeTo: baseEndpointUrl) else {
            fatalError("Bad resourceName: \(request.resourceName)")
        }
        
        if let req = request as? NACDeleteActivityRequest
        {
            baseUrl = baseUrl.appendingPathComponent(req.cloudID)
        }
        
        let components = URLComponents(url: baseUrl, resolvingAgainstBaseURL: true)!
        
        // (example) Common query items needed for Notio requests
//        let timestamp = "\(Date().timeIntervalSince1970)"
//        let hash = "\(timestamp)\(privateKey)\(publicKey)".md5
//        let commonQueryItems = [
//            URLQueryItem(name: "ts", value: timestamp),
//            URLQueryItem(name: "hash", value: hash),
//            URLQueryItem(name: "apikey", value: publicKey)
//        ]
//
        // Custom query items needed for this specific request
//        let customQueryItems: [URLQueryItem]
//
//        do {
//            customQueryItems = try URLQueryItemEncoder.encode(request)
//        } catch {
//            fatalError("Wrong parameters: \(error)")
//        }
//
//        components.queryItems = commonQueryItems + customQueryItems
        
        return components.url!
    }
}
